<!DOCTYPE html>
<html>

<head>
<meta charset="utf-8" http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Everit Documentation</title>
<link rel="icon" type="image/ico" href="../fonts/favicon.ico">
<!-- Bootstrap core CSS -->
<link href="../css/bootstrap.min.css" rel="stylesheet">

<!-- Documentation extras -->
<link href="../css/docs.min.css" rel="stylesheet">
<link href="../css/everit.css" rel="stylesheet">

<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
    <script src="../js/html5shiv.min.js"></script>
    <script src="../js/respond.min.js"></script>
    <script src="../js/respond.matchmedia.addListener.min.js"></script>
    <![endif]-->

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push([ '_setAccount', 'UA-15041869-4' ]);
  _gaq.push([ '_setDomainName', 'everit.org' ]);
  _gaq.push([ '_trackPageview' ]);
</script>
<style type="text/css">
.ecm-chapter {
    text-align: justify;
}
</style>
</head>

<body class="bs-docs-home" data-spy="scroll" data-target="#affix-nav">
  <a class="sr-only" href="#content">Skip to main content</a>

  <!-- Docs master nav -->
  <header class="navbar navbar-static-top bs-docs-nav" id="top" role="banner">
    <div class="container">
      <div class="navbar-header">
        <button class="navbar-toggle" type="button" data-toggle="collapse"
          data-target=".bs-navbar-collapse">
          <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span
            class="icon-bar"></span> <span class="icon-bar"></span>
        </button>
        <a href="index.html" class="navbar-brand ">Everit</a>
      </div>
      <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
        <ul class="nav navbar-nav ">
          <li><a href="components.html ">Components</a></li>
          <li><a href="documentation.html">Documentation</a></li>
          <li><a href="oldsite.html ">Old site</a></li>
        </ul>
        <ul class="nav navbar-nav navbar-right ">
          <li><a href="http://www.everit.biz " target="_blank">Enterprise</a></li>
          <li><a href="http://everitorg.wordpress.com/ " target="_blank">Blog</a></li>
        </ul>
      </nav>
    </div>
  </header>

  <div class="bs-docs-masthead everit-header" id="content" role="main">
    <div class="container ">
      <span class="bs-docs-booticon bs-docs-booticon-lg bs-docs-booticon-outline "> <img
        class="logo " src="../fonts/sbz_e.svg" alt="E">
      </span>
      <p class="lead ">Everit Component Model</p>
    </div>
  </div>
  <div class="container">
    <div class="col-md-10">
      <div class="bs-docs-featurette ecm-chapter" id="introduction">
        <h2 class="bs-docs-featurette-title ">Introduction</h2>
        <p>
          ECM is a <a href="http://wiki.osgi.org/wiki/Component_Models_Overview">component model</a>
          designed to work well in large OSGi based applications. Developers who have used <a
            href="http://wiki.osgi.org/wiki/Declarative_Services">Declarative Services</a> before
          will find the concept of ECM familiar.
        </p>
        <p>
          While modularization gives <a href="http://www.osgi.org/Technology/WhyOSGi">lots of
            benefits</a> to a project, developers often feel that the application skeleton is similar to
          a house of cards. If any of the component has an issue, part of the system collapses, and
          it is nearly impossible to find the origin of the problem. One of the goals of Everit
          Component Model is to help developers finding the cause of issues in OSGi.
        </p>
        <p>
          Instead of <a href="http://wiki.osgi.org/wiki/Whiteboard_Pattern">whiteboard pattern</a>,
          ECM supports the top-down configuration approach. While developers can wire components
          together with whiteboard pattern rapidly, they lose the ability of systematic issue
          detection. E.g.: When part of an application is not started, and no exception is thrown,
          it is hard to find the missing piece. Searching the issue is even harder when one has to
          fix an issue in an application that was written by other.
        </p>
        <p>With top-down configuration design, developers can start searching the problem from
          the top of the application skeleton and by walking down on the unsatisfied component
          graph, they can find the original cause of the issue rapidly. With ECM, designing OSGi
          based applications becomes easier and more fun.</p>
      </div>
      <div class="bs-docs-featurette ecm-chapter" id="quickstart">
        <h2 class="bs-docs-featurette-title ">Quick start</h2>
        <p>There are several ways to use the Everit Component Model. The easiest way is using
          OSGi extender pattern, while components can be created and started programmatically, too.</p>
        <h3 id="usage-extender">Using the Extender</h3>
        <p>During development time, add the following dependencies (with their dependencies
          transitively):</p>
        <ul>
          <li><p>
              <a href="#ecm-annotation">ecm-annotation</a>
            </p></li>
          <li><p>
              <a href="#ecm-extender-api">ecm-extender-api</a>
            </p></li>
          <li><p>
              <a href="http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22biz.aQute.bndlib%22">bndlib</a>
              with <i>provided</i> scope as it is only necessary for annotation processing
            </p></li>
        </ul>

        <p>In order to be picked up by the extender, the component class must be annotated in
          the following way:</p>
        <pre class="prettyprint lang-java">import org.everit.osgi.ecm.annotation.Component;
import aQute.bnd.annotation.headers.ProvideCapability;

@Component
@ProvideCapability(ns = ECMExtenderConstants.CAPABILITY_NS_COMPONENT,
    value = ECMExtenderConstants.CAPABILITY_ATTR_CLASS + "" + "=${@class}")
public class MyComponent {
}</pre>
        <p>
          The documentation of <a href="#ecm-annotation">ecm-annotation</a> OSGi bundle contains the
          full list of annotations that can be used during the creation of a component class.
        </p>
        <p>
          With a build tool that uses <i>bndlib</i> inside, the necessary MANIFEST header will be
          automatically generated. Such tools are bndtools and maven-bundle-plugin. If this
          automation is not available, the <i>Provide-Capability</i> header must be manually
          defined:
        </p>
        <pre class="prettyprint">Provide-Capability: org.everit.osgi.ecm.component;class="mypackage.MyComponent"</pre>
        <p>By having the necessary MANIFEST header, the ECM Extender will automatically pick up
          the specified class and look for annotations in it.</p>
        <p>In the runtime environment, the following OSGi bundle should be installed with its
          dependencies:</p>
        <ul>
          <li><p>
              <a href="#ecm-extender-ri">extender-ri</a>
            </p></li>
        </ul>
        <h3 id="usage-programmatic">Programmatic way</h3>
        <p>Everit Component Model is designed in the way that Components can be created
          programmatically, too. During the development and also on the running OSGi container, the
          following OSGi bundle with its dependencies should be used:</p>
        <ul>
          <li><p>
              <a href="#ecm-component-ri">ecm-component-ri</a>
            </p></li>
        </ul>
        <p>
          In the following example, a very simple <a href="ecm-component-container">ECM
            Component Container</a> is created and started within a Bundle-Activator:
        </p>
        <pre class="prettyprint lang-java">
import org.everit.osgi.ecm.component.ri.ComponentContainerFactory;
import org.everit.osgi.ecm.component.ri.ComponentContainerInstance;
import org.everit.osgi.ecm.metadata.ComponentMetadata;
import org.everit.osgi.ecm.metadata.ComponentMetadata.ComponentMetadataBuilder;
import org.osgi.framework.BundleActivator;
import org.osgi.framework.BundleContext;

public class MyActivator {

  private ComponentContainerInstance&lt;MyComponent&gt; myComponentContainer

  @Override
  public void start(final BundleContext context) {
    ComponentMetadataBuilder builder = new ComponentMetadataBuilder();
    ComponentMetadata metadata = builder.withType(MyComponent.class).build();

    ComponentContainerFactory factory = new ComponentContainerFactory(context);

    this.myComponentContainer = factory.createComponentContainer(metadata);
    this.myComponentContainer.open();
  }

  @Override
  public void stop(final BundleContext context) {
    this.myComponentContainer.close();
  }
}</pre>
        <p>
          For more information, how to build <i>ComponentMetadata</i> programmatically, see the
          documentation of <a href="#ecm-metadata">ecm-metadata</a> OSGi bundle!
        </p>
      </div>
      <div class="bs-docs-featurette ecm-chapter" id="specification">
        <h2 class="bs-docs-featurette-title ">Specification</h2>
        <h3 id="component-container">Component container</h3>
        <p>
          A <i>Component Container</i> is responsible for the instantiation and lifecycle of <a
            href="component-context">Component Contexts</a>. When the <i>Component Container</i> is
          opened, an OSGi service is registered with the following interfaces:
        </p>
        <table class="table">
          <thead>
            <tr>
              <th>Interface</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><span class="hidden-xs hidden-sm hidden-md">org.everit.osgi.ecm.component.resource.</span>ComponentContainer</td>
              <td>Used to retrieve all information about the state of the container instance.
                Programmers can list the instantiated components, get the <i>metadata</i> that
                belongs to the component, etc.
              </td>
            </tr>
            <tr>
              <td><a
                href="https://osgi.org/javadoc/r4v42/org/osgi/service/cm/ManagedService.html"><span
                  class="hidden-xs hidden-sm hidden-md">org.osgi.service.cm.</span>ManagedService</a></td>
              <td>Only if the <a href="#TBD">configuration policy</a> of the container is
                either <a href="#policy-optional">OPTIONAL</a> or <a href="#policy-required">REQUIRED</a>
              </td>
            </tr>
            <tr>
              <td><a
                href="https://osgi.org/javadoc/r4v42/org/osgi/service/cm/ManagedServiceFactory.html"><span
                  class="hidden-xs hidden-sm hidden-md">org.osgi.service.cm.</span>ManagedServiceFactory</a></td>
              <td>Only if the <a href="#TBD">configuration policy</a> of the container is <a
                href="#policy-factory">FACTORY</a>.
              </td>
            </tr>
            <tr>
              <td><a
                href="https://osgi.org/javadoc/r4v42/org/osgi/service/metatype/MetaTypeProvider.html"><span
                  class="hidden-xs hidden-sm hidden-md">org.osgi.service.metatype.</span>MetaTypeProvider</a></td>
              <td>Only if the <i>metatype</i> data belongs to the container.
              </td>
            </tr>
          </tbody>
        </table>
        <p>
          ECM relies on the <i>Configuration Admin</i> chapter of <i>OSGi Compendium
            specification</i>. If any configuration is necessary, <i>ComponentContainer</i> OSGi service
          is registered with <i>ManagedService</i> or <i>ManagedServiceFactory</i> interface. <i>Configuration
            Admin</i> notifies the <i>Component Container</i> by calling the OSGi service if a new
          configuration is available, a configuration was modified or a configuration was deleted.
          The behavior of the Component Container depends on the configuration policy:
        </p>
        <ul>
          <li><p>
              <strong id="policy-ignore">IGNORE</strong>: Neither ManagedService nor
              ManagedServieFactory interface is used when the ComponentContainer OSGi service is
              registered. The container instantiates and opens the <a href="#component-context">Component
                Context</a> as soon as the container is opened and all references of the component are
              satisfied.
            </p></li>
          <li><p>
              <strong id="policy-optional">OPTIONAL</strong>: One <a href="#component-context">Component
                Context</a> will be instantiated and opened as soon as the <i>Container</i> is started.
              In case a configuration is available, the Component Context will be upgraded. <strong><span
                class="text-danger">Although this is the default policy for components, we do
                  not recommend using it. Strange behavior can happen. E.g.: A component is created
                  during starting the framework than it is re-activated (and all dependent
                  components are re-activated recursively) when Confguration Admin starts.</span></strong>
            </p></li>
          <li><p>
              <strong id="policy-required">REQUIRED</strong>: The <a href="#component-context">Component
                Context</a> will be instantiated and opened only if a configuration is available. If the
              configuration is not available anymore, the <i>Container</i> closes the <a
                href="#component-context">Component Context</a>.
            </p></li>
          <li><p>
              <strong id="policy-factory">FACTORY</strong>: The <i>Container</i> will instantiate
              and open as many <a href="#component-context">Component Contexts</a> as many
              configuration is available.
            </p></li>
        </ul>
        <div class="clearfix">
          <div class="col-xs-10 col-xs-offset-1 col-md-5 col-md-offset-0 text-center"
            style="padding-bottom: 1em;">
            <img alt="Container-Context relation with Factory configuration policy"
              style="max-width: 100%;" src="container-context-factory.svg">
          </div>
          <div class="col-xs-10 col-xs-offset-1 col-md-5 col-md-offset-1 text-center"
            style="padding-bottom: 1em;">
            <img
              alt="Container-Context relation with Ignore, Optional or Required configuration policy"
              style="max-width: 100%;" src="container-context-simple.svg">
          </div>
        </div>
        <h3 id="component-context">Component context</h3>

        <p>
          <i>Component contexts</i> are instantiated and started by the <a
            href="#component-container">Component containers</a>. One <i>Component context</i>
          handles the lifecycle of exactly one <i>Component</i>.
        </p>
        <p>
          The <a href="#">ComponentContext</a> instance can be used within a component to
        </p>
        <ul>
          <li>get the current configuration of the component</li>
          <li>access the <i>metadata</i> of the component via the <i>component container</i>
          <li>access the <a
            href="https://osgi.org/javadoc/r4v43/core/org/osgi/framework/BundleContext.html">BundleContext</a>
            of the bundle that registered the <i>component container</i>
          <li>register OSGi services</li>
        </ul>
        <p>
          <strong class="text-danger">OSGi services should be registered always with <i>ComponentContext</i>
            and not via <i>BundleContext</i> directly!
          </strong> ECM can provide complete <a href="#">Component wiring</a> information only if OSGi
          services are registered via <i>ComponentContext</i>.
        </p>
        <p>
          Component developers can receive the <i>component context</i> by specifying it as a
          parameter of the <a href="">activate</a> method of the component.
        </p>


        <h3 id="component-lifecycle">Component lifecycle</h3>
        <h4>Component states</h4>
        <p>
          The <a href="#component-context">component context</a> manages the lifecycle of the
          component. A component might have one of the following states:
        </p>
        <table class="table">
          <thead>
            <tr>
              <th>State</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>INACTIVE</td>
              <td>The component is not yet initialized or it was removed. It is hard to catch
                this state as
                <ul>
                  <li>As soon as the component context is created, initialization starts.</li>
                  <li>As soon as the component context is inactivated, it is removed from the
                    system completely (as this happens when the container is closed).</li>
                </ul>
              </td>
            </tr>
            <tr>
              <td>UNSATISFIED</td>
              <td>The component has one or more unsatisfied <a href="reference-handling">references</a>.
              </td>
            </tr>
            <tr>
              <td>STARTING</td>
              <td><p>The component is trying to reach the ACTIVE phase. One of the
                  following options happen currently to the component:</p>
                <ul>
                  <li>The <i>Component context</i> currently instantiates the <i>component</i>
                  </li>
                  <li>The <i>Component context</i> calls the setters of the <i>component
                      instance</i>
                  </li>
                  <li>The <a href="#activate-method">Activate</a> method of the <i>component
                      instance</i> method is currently running
                  </li>
                  <li>The <i>Component context</i> currently registers the <i>component
                      instance</i> as an OSGi service.
                  </li>
                </ul></td>
            </tr>
            <tr>
              <td>ACTIVE</td>
              <td>The component becomes active if the the STARTING phase ran without any
                exception and if it is defined so, the instance is registered as an OSGi service.</td>
            </tr>
            <tr>
              <td>UPDATING_CONFIGURATION</td>
              <td><p>
                  The component was already in <i>ACTIVE</i> state when new <i>configuraiton</i> has
                  been applied that affects only <a href="#">dynamic attributes</a>. The component
                  leaves this state if
                </p>
                <ul>
                  <li>all properties are updated successfully, or an exception was thrown from
                    one of the setters</li>
                  <li>if specified, <a href="#">update method</a> was called and it returned
                    successfully or an exception was thrown from it.
                  </li>
                </ul></td>
            </tr>
            <tr>
              <td>STOPPING</td>
              <td><p>The deactivate function of the component is currently running if one
                  is specified. Several reasons reason can stop a component:</p>
                <ul>
                  <li>The component is destroyed as the configuration behind the component is
                    deleted</li>
                  <li>The component is destroyed as the <a href="#component-container">container</a>
                    of the component is closed.
                  </li>
                  <li>Due to a non-dynamic configuration update, the component has to be
                    restarted. In this case the first step is stopping the component.</li>
                  <li>The component was <i>STARTING</i> or it was in <i>ACTIVE</i> state and
                    there was a failure. In the end of STOPPING, the component will get the <i>FAILED</i>
                    state.
                  </li>
                  <li>The component was <i>ACTIVE</i> and one of the references became
                    unsatisfied.
                  </li>
                </ul>
                <p>By the end of the STOPPING state, the component context drops the component
                  instance.</p></td>
            </tr>
            <tr>
              <td>FAILED</td>
              <td>A component is in the failed state if any of the setter-, the activate- or
                the update method was called by the <i>context</i> and the method threw an
                exception.
              </td>
            </tr>
            <tr>
              <td>FAILED_PERMANENT</td>
              <td><p>
                  The component will be permanently failed if <i>metadata</i> of the component is
                  inconsistent. E.g.:
                </p>
                <ul>
                  <li>The class of the component cannot be found or instantiated.</li>
                  <li>Specified <i>Activate</i>, <i>Update</i> or <i>Deactivate</i> method does
                    not exist
                  </li>
                  <li>Any of the specified setters does not exist</li>
                </ul></td>
            </tr>
          </tbody>
        </table>
        <h4>Component configuration upgrade</h4>
        <p>
          The configuration of the component is upgraded if the <a href="#component-context">component
            context</a> is already created and a new configuration is available for the same context.
          This might happen in the following cases:
        </p>
        <ul>
          <li><p>
              If the <a href="configuration-policy">configuration policy</a> of the component is <a
                href="#policy-optional">OPTIONAL</a>, the <i>component context</i> is created with
              default configuration values. After that, any configuration creation, modification or
              deletion via Configuration Admin will result in a component configuration upgrade.
            </p></li>
          <li><p>
              If the <a href="configuration-policy">configuration policy</a> is <a
                href="#policy-required">REQUIRED</a>, the <a href="#component-context">component
                context</a> will be created as soon as there is a configuration for the component. A
              component configuration upgrade will happen always when the configuration is modified
              via Configuration Admin.
            </p></li>
          <li><p>
              If the <a href="configuration-policy">configuration policy</a> is <a
                href="#policy-factory">FACTORY</a>, as many <a href="#component-context">component
                context</a> will be created, as many configuration entry is available for the container
              in Configuration Admin. When an entry is changed, the connected <a
                href="#component-context">component context</a> will be updated.
            </p></li>
        </ul>
        <p>Depending on the state of the component and the changed attributes, a configuration
          upgrade can cause different events:</p>
        <ul>
          <li><p>If no component attribute is changed in the configuration, nothing will
              happen. It does not matter if such property is configured, that is not specified in
              the component.</p></li>
          <li><p>
              If the component is <a href="#state-failed-permanent">FAILED_PERMANENT</a>, nothing
              will happen.
            </p></li>
          <li><p>
              If the component is <a href="#state-active">ACTIVE</a> and any of the requirements
              become unsatisfied, the component will stop (<a href="#state-stopping">STOPPING</a>
              state) and than becomes <a href="#state-unsatisfied">UNSATISFIED</a>.
            </p></li>
          <li><p>
              If the component is <a href="#state-active">ACTIVE</a> and only <i>dynamic</i>
              attributes and requirements are changed, the <a href="#setter-method">setter
                methods</a> will be called first, and than the <a href="#update-method">update
                method</a>.
            </p></li>
          <li><p>
              If the component is <a href="#state-active">ACTIVE</a> and any of the <a
                href="#requirements">requirements</a> becomes unsatisfied, the component will be <a
                href="#state-stopping">stopped</a> and become <a href="#state-unsatisfied">UNSATISFIED</a>
              in the end.
            </p></li>
          <li><p>
              If the component is <a href="#state-active">ACTIVE</a> and any of the <i>non-dynamic</i>
              attributes or requirements is changed, the component will be restarted.
            </p></li>
          <li><p>
              If the component is <a href="#state-failed">FAILED</a> and after the configuration
              there are unsatisfied requirements, the component will become <a
                href="#state-unsatisfied">UNSATISFIED</a>.
            </p></li>
          <li><p>
              If the component is <a href="#state-unsatisfied">UNSATISFIED</a> or <a
                href="#state-failed">FAILED</a> and after the configuration upgrade all requirements
              is satisfied, the component will be started.
            </p></li>
        </ul>
        <h3 id="component-attributes">Component attributes</h3>
        <h4>Attribute types</h4>
        <p>An attribute always has one of the following types: boolean, byte, char, double,
          float, int, long, password, short, String.</p>
        <h4>Attribute cardinality</h4>
        <p>
          An attribute might be optional or required. In case of optional, the attribute value might
          be <i>undefined</i>. In case the attribute is not defined, its <i>setter</i> will not be
          called.
        </p>
        <p>
          An attribute has a "<i>multiple</i>" flag. If the "<i>multiple</i>" flag is <i>true</i>,
          the attribute can have more than one values. If a <i>setter</i> method is defined for a <i>multiple=true</i>
          attribute, the parameter of the setter must be the array of the attribute type. E.g.:
          int[], String[], ...
        </p>
        <h4>Dynamic attribute</h4>
        <p>Every time the value of the attribute changes (most likely via Configuration Admin)
          the following will happen:</p>
        <ul>
          <li>if the attribute is <i>non-dynamic</i>, the component will be restarted.
          </li>
          <li>if the attribute is <i>dynamic</i>, the <i>setter</i> method of the component (if
            there is any) will be called and the if the <a href="update-method">update method</a> is
            defined, it will be called as well.
        </ul>
        <h3 id="component-references">Component requirements</h3>
        <h4>Service reference</h4>
        <h4>Bundle-Capability reference</h4>
        <h3>Component capabilities</h3>
        <h4>Service capability</h4>
        <p>Manual and automatic...</p>
        <h3 id="component-methods">Component methods</h3>
        <h4>Setters</h4>
        <h4 id="activate-method">Activate method</h4>
        <h4 id="update-method">Update method</h4>
        <h4 id="deactivate-method">Deactivate method</h4>
        <h3>Metatype support</h3>
      </div>
      <div class="bs-docs-featurette ecm-chapter" id="modules">
        <h2 class="bs-docs-featurette-title ">OSGi Bundles</h2>
        <p>
          ECM is built up from several bundles. Each bundle has its purpose. The separation is
          necessary to keep the technology stable and to be able to fix bugs in short development
          iterations. All bundles are available on <a
            href="http://search.maven.org/#search%7Cga%7C1%7Corg.everit.osgi.ecm">maven-central</a>.
        </p>
        <p class="text-center">
          <img src="ecm-dependency-graph.svg" style="max-width: 100%;" />
        </p>
        <h3 id="ecm-extender-api">ECM Extender API</h3>
        <p>Hello extender api</p>
      </div>
      <div class="bs-docs-featurette ecm-chapter" id="webconsole-plugin">
        <h2 class="bs-docs-featurette-title ">Webconsole plugin</h2>

      </div>
    </div>
    <div class="col-md-2">
      <nav id="affix-nav">
        <ul class="nav nav-pills nav-stacked everit-affix affix-top" data-spy="affix"
          data-offset-top="350" data-offset-bottom="140">
          <li class=""><a href="#introduction">Introduction</a></li>
          <li class=""><a href="#quickstart">Quick start</a>
            <ul class="nav nav-pills nav-stacked">
              <li class=""><a href="#usage-extender">Using the extender</a></li>
              <li class=""><a href="#usage-programmatic">Programmatic way</a></li>
            </ul></li>
          <li class=""><a href="#specification">Specification</a>
            <ul class="nav nav-pills nav-stacked">
              <li class=""><a href="#component-container">Component container</a></li>
              <li class=""><a href="#component-context">Component context</a></li>
              <li class=""><a href="#component-lifecycle">Component lifecycle</a></li>
            </ul></li>
          <li class=""><a href="#reference-handling">Reference handling</a></li>
          <li class=""><a href="#osgi-bundles">OSGi Bundles</a></li>
        </ul>
      </nav>
    </div>
  </div>


  <!-- Footer
================================================== -->
  <div></div>
  <footer class="bs-docs-footer" role="contentinfo">
    <div class="container">
      <div class="bs-docs-social">
        <ul class="bs-docs-social-buttons">
          <li class="follow-btn"><a href="https://twitter.com/EveritOrg"
            class="twitter-follow-button" data-show-count="true">Follow @EveritOrg</a></li>
          <li class="tweet-btn"><a href="https://twitter.com/share"
            class="twitter-share-button" data-url="http://www.everit.org/">Tweet</a></li>
        </ul>
      </div>
    </div>
  </footer>

  <!-- Bootstrap core JavaScript
================================================== -->
  <!-- Placed at the end of the document so the pages load faster -->
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/bootstrap.min.js"></script>
  <script src="../js/everit.js"></script>
  <script type="text/javascript">
      (function() {
        var ga = document.createElement('script');
        ga.type = 'text/javascript';
        ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl'
            : 'http://www')
            + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(ga, s);
      })();
    </script>
  <script src="../js/prettify/run_prettify.js"></script>

</body>

</html>
